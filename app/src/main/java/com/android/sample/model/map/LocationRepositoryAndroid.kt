package com.android.sample.model.map

// Generated by AI
import android.Manifest
import android.app.Application
import android.content.pm.PackageManager
import android.os.Looper
import androidx.core.content.ContextCompat
import com.google.android.gms.location.LocationCallback
import com.google.android.gms.location.LocationRequest
import com.google.android.gms.location.LocationResult
import com.google.android.gms.location.LocationServices
import com.google.android.gms.location.Priority
import com.google.android.gms.tasks.CancellationTokenSource
import kotlinx.coroutines.channels.awaitClose
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.callbackFlow
import kotlinx.coroutines.tasks.await

/**
 * Android implementation of LocationRepository using Google Play Services' Fused Location Provider.
 *
 * @property app Application context needed to access location services.
 */
class LocationRepositoryAndroid(private val app: Application) : LocationRepository {

  /** Provider for android GPS */
  private val fusedClient = LocationServices.getFusedLocationProviderClient(app)

  /**
   * Fetches the user's current location.
   *
   * This method will attempt to get the user's location using the device's location services. It
   * first tries to get the last known location for efficiency. If no cached location is available,
   * it requests a fresh location from the GPS.
   *
   * @return The user's current Location.
   * @throws SecurityException if location permissions are not granted.
   * @throws Exception if location cannot be fetched.
   */
  override suspend fun getUserLocation(): Location {
    // Check for location permissions
    val fine = Manifest.permission.ACCESS_FINE_LOCATION
    val coarse = Manifest.permission.ACCESS_COARSE_LOCATION

    val hasLocationPermission =
        ContextCompat.checkSelfPermission(app, fine) == PackageManager.PERMISSION_GRANTED ||
            ContextCompat.checkSelfPermission(app, coarse) == PackageManager.PERMISSION_GRANTED

    if (!hasLocationPermission) {
      throw SecurityException("Location permission not granted")
    }

    // Try to get last known location first (faster and uses less battery)
    val lastLocation = fusedClient.lastLocation.await()

    return if (lastLocation != null) {
      Location(latitude = lastLocation.latitude, longitude = lastLocation.longitude)
    } else {
      // If no cached location, get current location
      val cancellationTokenSource = CancellationTokenSource()
      val currentLocation =
          fusedClient
              .getCurrentLocation(
                  Priority.PRIORITY_BALANCED_POWER_ACCURACY, cancellationTokenSource.token)
              .await()

      currentLocation?.let { Location(latitude = it.latitude, longitude = it.longitude) }
          ?: throw Exception("Unable to fetch user location")
    }
  }

  /**
   * Fetches the user's current location and checks if it is inside any of the provided areas.
   *
   * This method will attempt to get the user's location using the device's location services. It
   * first tries to get the last known location for efficiency. If no cached location is available,
   * it requests a fresh location from the GPS.
   *
   * @param areas List of Area objects to check against the user's location.
   * @return true if the user's location is inside any of the provided areas, false otherwise.
   * @throws SecurityException if location permissions are not granted.
   * @throws Exception if location cannot be fetched.
   */
  override suspend fun isUserLocationInAreas(areas: List<Area>): Boolean {
    val userLocation = getUserLocation()

    // Check if user location is inside any of the provided areas
    return areas.any { area ->
      val userMarker = Marker(location = userLocation)
      area.contains(userMarker)
    }
  }
}
