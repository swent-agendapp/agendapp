package com.android.sample.ui.map

import android.Manifest
import android.app.Application
import android.content.pm.PackageManager
import androidx.core.content.ContextCompat
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.viewModelScope
import com.android.sample.BuildConfig
import com.android.sample.model.map.Area
import com.android.sample.model.map.Location
import com.android.sample.model.map.MapRepository
import com.android.sample.model.map.MapRepositoryProvider
import com.android.sample.model.map.Marker
import com.android.sample.model.organization.repository.SelectedOrganizationRepository
import com.google.android.gms.location.LocationServices
import com.google.android.gms.location.Priority
import com.google.android.gms.maps.model.LatLng
import com.google.android.gms.tasks.CancellationTokenSource
import com.google.android.libraries.places.api.Places
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.launch

// All the documentation has been generated by IA

/** EPFL Location for default value */
object DefaultLocation {
  const val LATITUDE = 46.5191
  const val LONGITUDE = 6.5668
}

/**
 * Represents the Stat of the screen UI .
 *
 * @property currentLocation current Location of the phone. has default value centered in EPFL
 * @property listNewMarker list of marker placed by the User
 * @property listArea all the area created in the organisation
 * @property errorMessage in case where we cannot fetch the location, we show the error message.
 * @property hasPermission if the user has grant permission of location to our app.
 * @property nextAreaName if the user create an Area, we get it's name
 */
data class MapUiState(
    val currentLocation: LatLng = LatLng(DefaultLocation.LATITUDE, DefaultLocation.LONGITUDE),
    val listNewMarker: List<Marker> = emptyList(),
    val listArea: List<Area> = emptyList(),
    val hasPermission: Boolean = false,
    val errorMessage: String? = null,
    val nextAreaName: String = "Untitled",
)

class MapViewModel(
    app: Application,
    private val mapRepository: MapRepository = MapRepositoryProvider.repository
) : AndroidViewModel(app) {

  /** Provider for android GPS */
  private val fusedClient = LocationServices.getFusedLocationProviderClient(app)

  private val _state = MutableStateFlow(MapUiState())
  val state: StateFlow<MapUiState> = _state

  private val selectedOrganizationId: StateFlow<String?> =
      SelectedOrganizationRepository.selectedOrganizationId

  // Helper function to get the selected organization ID or throw an exception if none is selected
  fun getSelectedOrganizationId(): String {
    val orgId = selectedOrganizationId.value
    require(orgId != null) { "No organization selected" }
    return orgId
  }

  init {
    val apiKey = BuildConfig.MAPS_API_KEY
    Places.initializeWithNewPlacesApiEnabled(app, apiKey)
    fetchAllArea()
  }

  /**
   * Fetch all existing areas from the repository and update the current state with the full list.
   */
  fun fetchAllArea() {
    viewModelScope.launch {
      val areas = mapRepository.getAllAreas(getSelectedOrganizationId())
      _state.value = _state.value.copy(listArea = areas)
    }
  }

  /**
   * Create a new area based on the markers currently stored in the temporary list.
   *
   * Each marker is first saved in the repository. Then, a new area is created using the current
   * `nextAreaName`. After successful creation, the list of new markers and the area name are reset,
   * and all areas are re-fetched to refresh the state.
   *
   * If an invalid area name or configuration is detected, the function catches
   * [IllegalArgumentException] and updates the state with the corresponding error message.
   */
  fun createNewArea() {
    viewModelScope.launch {
      _state.value.listNewMarker.forEach { marker ->
        mapRepository.addMarker(getSelectedOrganizationId(), marker)
      }
      try {
        mapRepository.createArea(
            orgId = getSelectedOrganizationId(),
            label = _state.value.nextAreaName,
            markerIds = _state.value.listNewMarker.map { it.id })
        _state.value = _state.value.copy(listNewMarker = emptyList(), nextAreaName = "Untitled")
        fetchAllArea()
      } catch (e: IllegalArgumentException) {
        _state.value = _state.value.copy(errorMessage = e.message)
      }
    }
  }

  /**
   * Add a new marker to the temporary list of markers used for creating a new area.
   *
   * @param coordinate The geographical position (latitude and longitude) of the new marker.
   */
  fun addNewMarker(coordinate: LatLng) {
    viewModelScope.launch {
      _state.value =
          _state.value.copy(
              listNewMarker =
                  listOf(Marker(location = Location(coordinate.latitude, coordinate.longitude))) +
                      _state.value.listNewMarker)
    }
  }

  /**
   * Delete a marker from the temporary list of markers being used to define a new area.
   *
   * @param markerId The unique identifier of the marker to be removed.
   */
  fun deleteMarker(markerId: String) {
    _state.value =
        _state.value.copy(
            listNewMarker = _state.value.listNewMarker.filter { marker -> marker.id != markerId })
  }

  /**
   * Set or update the name of the area currently being created.
   *
   * @param areaName The new name to assign to the area.
   */
  fun setNewAreaName(areaName: String) {
    _state.value = _state.value.copy(nextAreaName = areaName)
  }

  /** Clear the current error message in the state, if any, to reset the UI to a neutral state. */
  fun cleanMessageError() {
    _state.value = _state.value.copy(errorMessage = null)
  }

  /**
   * Verify that the user has given the right to get his location
   *
   * then fetch the User Location, if another app has already fetch it, it get this cached value
   * with lastLocation
   *
   * if there is no cached location, it ask the GPS to compute a new one with getCurrentLocation
   *
   * if the provider make an error, it update the State to an error State
   */
  fun fetchUserLocation() {
    val app = getApplication<Application>()
    val fine = Manifest.permission.ACCESS_FINE_LOCATION
    val coarse = Manifest.permission.ACCESS_COARSE_LOCATION
    val cancellationTokenSource = CancellationTokenSource()

    val hasLocationPermission =
        ContextCompat.checkSelfPermission(app, fine) == PackageManager.PERMISSION_GRANTED ||
            ContextCompat.checkSelfPermission(app, coarse) == PackageManager.PERMISSION_GRANTED

    if (!hasLocationPermission) {
      _state.value =
          _state.value.copy(
              errorMessage =
                  "Location permission required\nTo show your position on the map, we need access to your location. Please enable it in your device settings.",
              hasPermission = false)
      return
    }

    fusedClient.lastLocation
        .addOnSuccessListener { lastLocation ->
          if (lastLocation == null) {
            fusedClient
                .getCurrentLocation(
                    Priority.PRIORITY_BALANCED_POWER_ACCURACY, cancellationTokenSource.token)
                .addOnSuccessListener { location ->
                  if (location == null) {
                    _state.value =
                        _state.value.copy(
                            errorMessage = "Error: Cannot fetch you location", hasPermission = true)
                  } else {
                    _state.value =
                        _state.value.copy(
                            currentLocation = LatLng(location.latitude, location.longitude),
                            hasPermission = true)
                  }
                }
                .addOnFailureListener { e ->
                  _state.value = _state.value.copy(errorMessage = e.message, hasPermission = true)
                }
          } else {
            _state.value =
                _state.value.copy(
                    currentLocation = LatLng(lastLocation.latitude, lastLocation.longitude),
                    hasPermission = true)
          }
        }
        .addOnFailureListener { e ->
          _state.value = _state.value.copy(errorMessage = e.message, hasPermission = true)
        }
  }
}
