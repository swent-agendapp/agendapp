package com.android.sample.ui.map

import android.app.Application
import androidx.lifecycle.ViewModel
import androidx.lifecycle.ViewModelProvider
import androidx.lifecycle.viewModelScope
import androidx.lifecycle.viewmodel.initializer
import androidx.lifecycle.viewmodel.viewModelFactory
import com.android.sample.BuildConfig
import com.android.sample.model.map.Area
import com.android.sample.model.map.LocationRepository
import com.android.sample.model.map.LocationRepositoryAndroid
import com.android.sample.model.map.MapRepository
import com.android.sample.model.map.MapRepositoryProvider
import com.android.sample.model.map.Marker
import com.android.sample.model.organization.repository.SelectedOrganizationRepository
import com.google.android.gms.maps.model.LatLng
import com.google.android.libraries.places.api.Places
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.launch

// All the documentation has been generated by IA

/** EPFL Location for default value */
object DefaultLocation {
  const val LATITUDE = 46.5191
  const val LONGITUDE = 6.5668
}

/** EPFL Location for default value */
object DefaultMarkerValue {
  const val RADIUS = 10.0
  const val LABEL = "Untitled"
}

/**
 * Represents the Stat of the screen UI .
 *
 * @property currentLocation current Location of the phone. has default value centered in EPFL
 * @property listNewMarker list of marker placed by the User
 * @property listArea all the area created in the organisation
 * @property errorMessage in case where we cannot fetch the location, we show the error message.
 * @property hasPermission if the user has grant permission of location to our app.
 * @property nextAreaName if the user create an Area, we get it's name
 */
data class MapUiState(
    val currentLocation: LatLng = LatLng(DefaultLocation.LATITUDE, DefaultLocation.LONGITUDE),
    val listArea: List<Area> = emptyList(),
    val hasPermission: Boolean = false,
    val errorMessage: String? = null,
    val selectedAreaName: String = "",
    val selectedRadius: Double = DefaultMarkerValue.RADIUS,
    val selectedMarker: Marker? = null,
    val selectedId: String? = null,
    val showBottomBar: Boolean = false
)

class MapViewModel(
    app: Application,
    private val mapRepository: MapRepository = MapRepositoryProvider.repository,
    private val locationRepository: LocationRepository = LocationRepositoryAndroid(app)
) : ViewModel() {

  private val _state = MutableStateFlow(MapUiState())
  val state: StateFlow<MapUiState> = _state

  private val selectedOrganizationId: StateFlow<String?> =
      SelectedOrganizationRepository.selectedOrganizationId

  // Helper function to get the selected organization ID or throw an exception if none is selected
  private fun getSelectedOrganizationId(): String {
    val orgId = selectedOrganizationId.value
    require(orgId != null) { "No organization selected" }
    return orgId
  }

  init {
    val apiKey = BuildConfig.MAPS_API_KEY
    Places.initializeWithNewPlacesApiEnabled(app, apiKey)
    fetchAllArea()
    fetchUserLocation()
  }

  /**
   * Fetch all existing areas from the repository and update the current state with the full list.
   */
  fun fetchAllArea() {
    viewModelScope.launch {
      val areas = mapRepository.getAllAreas(getSelectedOrganizationId())
      _state.value = _state.value.copy(listArea = areas)
    }
  }

  /**
   * Add a new marker to the temporary list of markers used for creating a new area.
   *
   * @param position The geographical position (latitude and longitude) of the new marker.
   */
  fun createArea(position: LatLng) {
    _state.value =
        _state.value.copy(
            selectedMarker = Marker(latitude = position.latitude, longitude = position.longitude),
            selectedRadius = DefaultMarkerValue.RADIUS,
            selectedAreaName = "",
            showBottomBar = true)
  }

  fun hideBottomBar() {
    _state.value = _state.value.copy(showBottomBar = false)
    this.unselectArea()
  }

  /**
   * Create a new area based on the markers currently stored in the temporary list.
   *
   * Each marker is first saved in the repository. Then, a new area is created using the current
   * `nextAreaName`. After successful creation, the list of new markers and the area name are reset,
   * and all areas are re-fetched to refresh the state.
   *
   * If an invalid area name or configuration is detected, the function catches
   * [IllegalArgumentException] and updates the state with the corresponding error message.
   */
  fun createNewArea() {
    require(_state.value.selectedMarker != null)
    viewModelScope.launch {
      val areaName = _state.value.selectedAreaName.ifBlank { DefaultMarkerValue.LABEL }
      mapRepository.createArea(
          orgId = getSelectedOrganizationId(),
          label = areaName,
          marker = _state.value.selectedMarker!!,
          radius = _state.value.selectedRadius)
      unselectArea()
      fetchAllArea()
    }
  }

  fun updateArea() {
    require(_state.value.selectedMarker != null)
    require(_state.value.selectedId != null)
    viewModelScope.launch {
      val areaName = _state.value.selectedAreaName.ifBlank { DefaultMarkerValue.LABEL }
      mapRepository.updateArea(
          areaId = _state.value.selectedId!!,
          orgId = getSelectedOrganizationId(),
          label = areaName,
          marker = _state.value.selectedMarker!!,
          radius = _state.value.selectedRadius)
      unselectArea()
      fetchAllArea()
    }
  }

  /**
   * Delete a marker from the temporary list of markers being used to define a new area.
   *
   * @param markerId The unique identifier of the marker to be removed.
   */
  fun deleteArea() {
    require(_state.value.selectedMarker != null)
    viewModelScope.launch {
      mapRepository.deleteArea(orgId = getSelectedOrganizationId(), _state.value.selectedId!!)
      unselectArea()
      fetchAllArea()
    }
  }

  /**
   * Set or update the name of the area currently being created.
   *
   * @param areaName The new name to assign to the area.
   */
  fun setNewAreaName(areaName: String) {
    _state.value = _state.value.copy(selectedAreaName = areaName)
  }

  /**
   * Set or update the radius of the area currently being created.
   *
   * @param areaRadius The new name to assign to the area.
   */
  fun setNewAreaRadius(areaRadius: Double) {
    _state.value = _state.value.copy(selectedRadius = areaRadius)
  }

  /** Clear the current error message in the state, if any, to reset the UI to a neutral state. */
  fun cleanMessageError() {
    _state.value = _state.value.copy(errorMessage = null)
  }

  /**
   * Set or update the name of the area currently being created.
   *
   * @param areaName The new name to assign to the area.
   */
  fun selectArea(area: Area) {
    _state.value =
        _state.value.copy(
            selectedAreaName = area.label,
            selectedRadius = area.radius,
            selectedMarker = area.marker,
            selectedId = area.id,
            showBottomBar = true)
  }

  /**
   * Set or update the name of the area currently being created.
   *
   * @param areaName The new name to assign to the area.
   */
  fun unselectArea() {
    _state.value =
        _state.value.copy(
            selectedMarker = null,
            selectedAreaName = "",
            selectedRadius = DefaultMarkerValue.RADIUS,
            selectedId = null)
  }

  /**
   * Fetches the user's current location using the LocationRepository.
   *
   * This method attempts to get the user's location. If successful, it updates the UI state with
   * the new location. If it fails (due to missing permissions or other errors), it updates the
   * state with an appropriate error message.
   */
  fun fetchUserLocation() {
    viewModelScope.launch {
      try {
        val location = locationRepository.getUserLocation()
        _state.value =
            _state.value.copy(
                currentLocation = LatLng(location.latitude, location.longitude),
                hasPermission = true)
      } catch (e: SecurityException) {
        _state.value =
            _state.value.copy(
                errorMessage =
                    "Location permission required\nTo show your position on the map, we need access to your location. Please enable it in your device settings.",
                hasPermission = false)
      } catch (e: Exception) {
        _state.value =
            _state.value.copy(
                errorMessage = e.message ?: "Error: Cannot fetch your location",
                hasPermission = true)
      }
    }
  }

  companion object {
    val Factory: ViewModelProvider.Factory = viewModelFactory {
      initializer {
        val app = this[ViewModelProvider.AndroidViewModelFactory.APPLICATION_KEY] as Application
        MapViewModel(app = app)
      }
    }
  }
}
