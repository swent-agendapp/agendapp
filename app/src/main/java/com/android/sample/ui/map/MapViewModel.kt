package com.android.sample.ui.map

import android.Manifest
import android.app.Application
import android.content.pm.PackageManager
import androidx.core.content.ContextCompat
import androidx.lifecycle.AndroidViewModel
import com.android.sample.BuildConfig
import com.android.sample.model.map.Area
import com.android.sample.model.map.Location
import com.android.sample.model.map.MapRepository
import com.android.sample.model.map.MapRepositoryLocal
import com.android.sample.model.map.Marker
import com.google.android.gms.location.LocationServices
import com.google.android.gms.location.Priority
import com.google.android.gms.maps.model.LatLng
import com.google.android.gms.tasks.CancellationTokenSource
import com.google.android.libraries.places.api.Places
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow

// All the documentation has been generated by IA

/** EPFL Location for default value */
object DefaultLocation {
  const val LATITUDE = 46.5191
  const val LONGITUDE = 6.5668
}

/**
 * Represents the Stat of the screen UI .
 *
 * @property currentLocation current Location of the phone. has default value centered in EPFL
 * @property listNewMarker list of marker placed by the User
 * @property listArea all the area created in the organisation
 * @property errorMessage in case where we cannot fetch the location, we show the error message.
 * @property hasPermission if the user has grant permission of location to our app.
 * @property nextAreaName if the user create an Area, we get it's name
 */
data class MapUiState(
    val currentLocation: LatLng = LatLng(DefaultLocation.LATITUDE, DefaultLocation.LONGITUDE),
    val listNewMarker: List<Marker> = emptyList(),
    val listArea: List<Area> = emptyList(),
    val hasPermission: Boolean = false,
    val errorMessage: String? = null,
    val nextAreaName: String = "Untitled",
)

class MapViewModel(
    app: Application,
) : AndroidViewModel(app) {

  private val mapRepository: MapRepository = MapRepositoryLocal()

  /** Provider for android GPS */
  private val fusedClient = LocationServices.getFusedLocationProviderClient(app)

  private val _state = MutableStateFlow(MapUiState())
  val state: StateFlow<MapUiState> = _state

  init {
    val apiKey = BuildConfig.MAPS_API_KEY
    Places.initializeWithNewPlacesApiEnabled(app, apiKey)
    fetchAllArea()
  }

  /**
   * Fetch all existing areas from the repository and update the current state with the full list.
   */
  fun fetchAllArea() {
    _state.value = _state.value.copy(listArea = mapRepository.getAllAreas())
  }

  /**
   * Create a new area based on the markers currently stored in the temporary list.
   *
   * Each marker is first saved in the repository. Then, a new area is created using the current
   * `nextAreaName`. After successful creation, the list of new markers and the area name are reset,
   * and all areas are re-fetched to refresh the state.
   *
   * If an invalid area name or configuration is detected, the function catches
   * [IllegalArgumentException] and updates the state with the corresponding error message.
   */
  fun createNewArea() {
    _state.value.listNewMarker.forEach { marker -> mapRepository.addMarker(marker) }
    try {
      mapRepository.createArea(label = _state.value.nextAreaName, markerIds = _state.value.listNewMarker.map { it.id })
      _state.value = _state.value.copy(listNewMarker = emptyList(), nextAreaName = "Untitled")
      fetchAllArea()
    } catch (e: IllegalArgumentException) {
      _state.value = _state.value.copy(errorMessage = e.message)
    }
  }

  /**
   * Add a new marker to the temporary list of markers used for creating a new area.
   *
   * @param coordinate The geographical position (latitude and longitude) of the new marker.
   */
  fun addNewMarker(coordinate: LatLng) {
    _state.value =
        _state.value.copy(
            listNewMarker =
                listOf(Marker(location = Location(coordinate.latitude, coordinate.longitude))) +
                    _state.value.listNewMarker)
  }

  /**
   * Delete a marker from the temporary list of markers being used to define a new area.
   *
   * @param markerId The unique identifier of the marker to be removed.
   */
  fun deleteMarker(markerId: String) {
    _state.value =
        _state.value.copy(
            listNewMarker = _state.value.listNewMarker.filter { marker -> marker.id != markerId })
  }

  /**
   * Set or update the name of the area currently being created.
   *
   * @param areaName The new name to assign to the area.
   */
  fun setNewAreaName(areaName: String) {
    _state.value = _state.value.copy(nextAreaName = areaName)
  }

  /** Clear the current error message in the state, if any, to reset the UI to a neutral state. */
  fun cleanMessageError() {
    _state.value = _state.value.copy(errorMessage = null)
  }

  /**
   * Verify that the user has given the right to get his location
   *
   * then fetch the User Location, if another app has already fetch it, it get this cached value
   * with lastLocation
   *
   * if there is no cached location, it ask the GPS to compute a new one with getCurrentLocation
   *
   * if the provider make an error, it update the State to an error State
   */
  fun fetchUserLocation() {
    val app = getApplication<Application>()
    val fine = Manifest.permission.ACCESS_FINE_LOCATION
    val coarse = Manifest.permission.ACCESS_COARSE_LOCATION
    val cancellationTokenSource = CancellationTokenSource()

    val hasLocationPermission =
        ContextCompat.checkSelfPermission(app, fine) == PackageManager.PERMISSION_GRANTED ||
            ContextCompat.checkSelfPermission(app, coarse) == PackageManager.PERMISSION_GRANTED

    if (!hasLocationPermission) {
      _state.value =
          MapUiState(
              errorMessage =
                  "Location permission required\nTo show your position on the map, we need access to your location. Please enable it in your device settings.")
      return
    }

    fusedClient.lastLocation
        .addOnSuccessListener { lastLocation ->
          if (lastLocation == null) {
            fusedClient
                .getCurrentLocation(
                    Priority.PRIORITY_BALANCED_POWER_ACCURACY, cancellationTokenSource.token)
                .addOnSuccessListener { location ->
                  if (location == null) {
                    _state.value =
                        MapUiState(
                            errorMessage = "Error: Cannot fetch you location", hasPermission = true)
                  } else {
                    _state.value =
                        MapUiState(
                            currentLocation = LatLng(location.latitude, location.longitude),
                            hasPermission = true)
                  }
                }
                .addOnFailureListener { e ->
                  _state.value = MapUiState(errorMessage = e.message, hasPermission = true)
                }
          } else {
            _state.value =
                MapUiState(
                    currentLocation = LatLng(lastLocation.latitude, lastLocation.longitude),
                    hasPermission = true)
          }
        }
        .addOnFailureListener { e ->
          _state.value = MapUiState(errorMessage = e.message, hasPermission = true)
        }
  }
}
